/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS201: Simplify complex destructure assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
let initialDocjson, open_file;
import React from 'react';
import createReactClass from 'create-react-class';
import _l from 'lodash';
import { Editor } from '../editor/edit-page';
import { Doc } from '../doc';
import core from '../core';
import config from '../config';
import util from '../util';

// This loads node.js APIs if in electron.  If run in a browser, this should crash, or something.
// We want to be careful to not use 'require' or webpack might try to bundle the node modules for
// us, or something.  This file will be built into the static js package that's on the cloud editor
// that runs in the web, so let's try not to break it.
const fs = window.require('fs');
const path = window.require('path');
const electron = window.require('electron').remote;
const filendir = window.require('filendir');
const readdirRecursive = window.require('fs-readdir-recursive');

const currentWindow = electron.getCurrentWindow(['openFile']);

const openResults = electron.dialog.showOpenDialog();

if (openResults != null) {
    open_file = openResults[0];
    initialDocjson = JSON.parse(fs.readFileSync(open_file, 'utf-8'));

} else {
    open_file = electron.dialog.showSaveDialog({
        defaultPath: 'untitled.pagedraw.json',
        buttonLabel: 'Create'
    });
    initialDocjson = (new Doc()).serialize();
    fs.writeFileSync(open_file, initialDocjson, 'utf-8');
}

if (typeof currentWindow.setRepresentedFilename === 'function') {
    currentWindow.setRepresentedFilename(open_file);
}

export default createReactClass({
    componentWillMount() {},

    componentDidMount() {
        currentWindow.maximize();
        return currentWindow.show();
    },

    render() {
        return React.createElement(Editor, { 
            "initialDocJson": (initialDocjson),  
            "onChange": (this.handleDocjsonChanged),  
            "windowTitle": "Pagedraw"
        });
    },

    handleDocjsonChanged(docjson) {
        // save the .pagedraw file
        fs.writeFileSync(open_file, JSON.stringify(docjson), 'utf-8');

        // write the compiled files
        const root_dir = path.dirname(open_file);
        const managed_dir = path.join(root_dir, 'src/pagedraw/');
        const generated_by_header = `Generated by ${path.basename(open_file)}`;

        // pass extra arguments to compileReact through compileDocâ€” not great
        config.extraJSPrefix = `// ${generated_by_header}`;
        config.extraCSSPrefix = `/* ${generated_by_header} */`;
        let build_results = core.compileDoc(Doc.deserialize(docjson));

        build_results = build_results.map(r => [path.join(root_dir, r.filePath), r.contents]);

        // don't let files go outside the managed directory
        build_results = build_results.filter(function(...args) { let contents;
        let filePath; [filePath, contents] = Array.from(args[0]); return isInsideDir(managed_dir, filePath); });

        const existing_built_files = _l.fromPairs(readdirRecursive(managed_dir).map(function(existing_file_path_inside_managed_dir) {
            const existing_file_path = path.join(managed_dir, existing_file_path_inside_managed_dir);
            const is_overwritable =
                (() => { try {
                    const first_5_lines = fs.readFileSync(existing_file_path, 'utf-8').split('\n').slice(0, 5).join('\n');

                    // see if any of them match pattern
                    return _l.includes(first_5_lines, generated_by_header);

                } catch (error) {
                    // if the read fails, we treat the file as not existing
                    return undefined;
                } })();

            return [existing_file_path, is_overwritable];}));

        return (() => {
            const result = [];
            const object = util.zip_dicts([_l.fromPairs(build_results), existing_built_files]);
            for (let filePath in object) {
                const [new_contents, is_overwritable] = object[filePath];
                if ((is_overwritable === true) && (new_contents == null)) {
                    result.push(fs.unlinkSync(filePath));

                } else if (((is_overwritable === true) || (is_overwritable === undefined)) && (new_contents != null)) {
                    result.push(filendir.writeFile(filePath, new_contents, (function() { })));
                } else {
                    result.push(undefined);
                }
            }
            return result;
        })();
    }
});

// else if new_contents? and is_overwritable == false then no-op; someone else owns the file
// else if not new_contents? and is_overwritable == false then no-op; not relevant to us
// else if not new_contents? and is_overwritable == undefined then no-op; not relevant to us


// definitely not "right", kind of a hack
var isInsideDir = (dir_path, file_path) => file_path.startsWith(dir_path);
